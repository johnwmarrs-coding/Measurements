/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package measurements;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

/*
	Improvement Ideas:
	1) Consider different UI
	2) Improve exception handling / usability depending on desired behavior
	3) Do more to improve output visually. Currently it printing a minimal message
	4) If you remove the name from the Measurement class, you could have a single method
	for calculating averages, and then store the named measurements in a data structure similar to the
	following: HashMap<String, ArrayList<Measurement>>. In that style, you could just call your generic
	calculateWeightedAverage method on each ArrayList.
	5) Allow user to just read in an input file like JSON.
	6) Use some sort of auto documenation generation system. Some are based on annotations, others on comments.
	7) Add more comments (personally I think the code is relatively self-explanatory)
*/

/*
 * Pretend input will be in the following form in stdin
 * 0 											<- Flag indicating whether data is named
 * N 											<- Number of measurements to read from
 * "Name1" {value} {weight} 					<- Measurement entries with names
 * {value} {weight}								<- Measurement entries without names
 * etc...
 */
public class App {
	public static void main(String[] args) {
		// Scanner to read measurements from stdin
		Scanner scanner = new Scanner(System.in);
		System.out.println("Will this data contain names? 0 = no, else = yes:");
		int containsNamesSelection = scanner.nextInt();
		boolean containsNames = containsNamesSelection != 0;

		System.out.println("Number of measurements to input:");
		int numMeasurements = scanner.nextInt();

		ArrayList<Measurement> measurements = new ArrayList<Measurement>();

		if (containsNames) {
			System.out.println("Enter each measurement in the following form: ");
			System.out.println("name value weight");
			for (int i = 0; i < numMeasurements; i++) {
				String name = scanner.next();
				double value = scanner.nextDouble();
				double weight = scanner.nextDouble();
				measurements.add(new Measurement(name, value, weight));
			}
			System.out.println("Result:");
			System.out.println(calculateGroupWeightedAverage(measurements));
		} else {
			System.out.println("Enter each measurement in the following form: ");
			System.out.println("value weight");
			for (int i = 0; i < numMeasurements; i++) {
				double value = scanner.nextDouble();
				double weight = scanner.nextDouble();
				measurements.add(new Measurement(value, weight));
			}
			System.out.println("Result:");
			System.out.println(calculateWeightedAverage(measurements));
		}

	}

	public static double calculateWeightedAverage(ArrayList<Measurement> measurements) {
		// Return 0 if no measurements are provided, could also throw errors if desired.
		if (measurements == null) {
			return 0;
		}
		double sumValue = 0.0;
		double sumWeight = 0.0;

		for (Measurement current : measurements) {
			// Ignoring negatively weighted measurements, prepare the numerator and denominator via summing.
			if (current.getWeight() > 0) {
				sumValue += current.getValue() * current.getWeight();
				sumWeight += current.getWeight();
			}
		}
		// Return 0 if division is impossible, otherwise return according to provided formula.
		if (sumWeight > 0) {
			return (sumValue / sumWeight);
		} else {
			return 0;
		}
	}

	public static HashMap<String, Double> calculateGroupWeightedAverage(ArrayList<Measurement> measurements) {
		// If input is null, or empty ArrayList then return empty HashMap of results.
		// (Other common validation may be to throw errors as necessary)
		if (measurements == null || measurements.size() == 0) {
			return new HashMap<String, Double>();
		}
		HashMap<String, Double> sumValues = new HashMap<String, Double>();
		HashMap<String, Double> sumWeights = new HashMap<String, Double>();
		HashMap<String, Double> results = new HashMap<String, Double>();

		for (Measurement current : measurements) {
			if (current.getWeight() > 0) {
				if (!sumValues.containsKey(current.getName())) {
					sumValues.put(current.getName(), 0.0);
				}
				if (!sumWeights.containsKey(current.getName())) {
					sumWeights.put(current.getName(), 0.0);
				}

				sumValues.put(current.getName(),
						sumValues.get(current.getName()) + current.getValue() * current.getWeight());

				sumWeights.put(current.getName(), sumWeights.get(current.getName()) + current.getWeight());
			}
		}

		// Return 0 if division is impossible, otherwise return according to provided formula.
		for (String key : sumValues.keySet()) {
			if (sumWeights.get(key) > 0) {
				results.put(key, sumValues.get(key) / sumWeights.get(key));
			} else {
				results.put(key, 0.0);
			}
		}

		return results;
	}
}
